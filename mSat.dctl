#line 2 //Debugging line

// Saturation Enhancer DCTL

// Define user interface parameters for DCTL
DEFINE_UI_PARAMS(Saturation, Saturation, DCTLUI_SLIDER_FLOAT, 0, -1, 1.0, 0.1)       // Saturation adjustment control
DEFINE_UI_PARAMS(Vibrance, Vibrance, DCTLUI_SLIDER_FLOAT, 0.0, -1.0, 1.0, 0.05)      // Vibrance adjustment control
DEFINE_UI_PARAMS(highlightMask, Highlight Recovery, DCTLUI_SLIDER_FLOAT, 0, 0.0, 1, 0.01) // Highlight recovery strength control
DEFINE_UI_PARAMS(shadowMask, Shadow Recovery, DCTLUI_SLIDER_FLOAT, 0, 0.0, 1, 0.01)  // Shadow recovery strength control
DEFINE_UI_PARAMS(Mix, Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)                 // Control for mixing processed and original image
DEFINE_UI_PARAMS(showMask, View Mask, DCTLUI_CHECK_BOX, 0)                           // Checkbox to toggle viewing of the mask

// Function to calculate highlight mask based on input RGB and slider value
__DEVICE__ float hMask(float R, float G, float B, float sliderValue) {
    float luminance = 0.299f * R + 0.587f * G + 0.114f * B;        // Calculate luminance
    float multiplier = sliderValue * _powf(luminance, 1.0f);       // Compute multiplier based on luminance
    return _saturatef(_powf(_fmaxf(1.0f - R, 0.0f), multiplier) *  // Calculate highlight mask
                      _powf(_fmaxf(1.0f - G, 0.0f), multiplier) *
                      _powf(_fmaxf(1.0f - B, 0.0f), multiplier));
}

// Function to calculate shadow mask based on input RGB and slider value
__DEVICE__ float sMask(float R, float G, float B, float sliderValue) {
    float luminance = 0.299f * R + 0.587f * G + 0.114f * B;        // Calculate luminance
    float multiplier = sliderValue * (1.0f - _powf(luminance, 1.0f)); // Compute multiplier based on luminance
    return _saturatef(_powf(_fmaxf(R, 0.0f), multiplier / 3.0f) *  // Calculate shadow mask
                      _powf(_fmaxf(G, 0.0f), multiplier / 3.0f) *
                      _powf(_fmaxf(B, 0.0f), multiplier / 3.0f));
}

// Main transformation function
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float3 rgb = make_float3(_fmaxf(p_R, 0.0f), _fmaxf(p_G, 0.0f), _fmaxf(p_B, 0.0f)); // Ensure initial RGB values are non-negative
    float ach = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));                                  // Calculate the achromatic axis (brightness level)
    float minColor = _fminf(rgb.x, _fminf(rgb.y, rgb.z));                             // Minimum value among RGB components
    float currentSaturation = ach == 0.0f ? 0.0f : (ach - minColor) / ach;            // Compute current saturation

    // Adjust the application of Vibrance
    float adjustedSaturationEffect = Vibrance > 0 ? 
        1.0f + (1.0f - currentSaturation) * Vibrance : 
        1.0f + currentSaturation * Vibrance;

    // Compute distance from the achromatic axis for saturation adjustment
    float3 distance = ach == 0.0f ? 0.0f : (ach - rgb) / _fabs(ach);
    distance *= (1.0f + Saturation) * adjustedSaturationEffect;

    // Calculate new RGB values with adjusted saturation
    float3 newRGB = make_float3(_fmaxf(ach - distance.x * _fabs(ach), 0.0f),
                                _fmaxf(ach - distance.y * _fabs(ach), 0.0f),
                                _fmaxf(ach - distance.z * _fabs(ach), 0.0f));

    // Mix the new and original RGB values
    newRGB = rgb * (1.0f - Mix) + newRGB * Mix;

    // Calculate high and low masks for highlight and shadow recovery
    float highMask = 1.0f - hMask(rgb.x, rgb.y, rgb.z, highlightMask);
    float lowMask = 1.0f - sMask(rgb.x, rgb.y, rgb.z, shadowMask);
    float combinedMask = _fminf(highMask + lowMask, 1.0f); // Combine the masks and normalize if needed

    // Combine high and low masks, ensuring the result is non-negative
    float3 outputRGB = rgb * combinedMask + (1.0f - combinedMask) * newRGB;
    outputRGB = make_float3(_fmaxf(outputRGB.x, 0.0f), _fmaxf(outputRGB.y, 0.0f), _fmaxf(outputRGB.z, 0.0f)); // Ensure no negative values

    // Check if Show mask box is ticked
    if (showMask) {
        return make_float3(combinedMask, combinedMask, combinedMask); // Output the mask if enabled
    }

    return outputRGB; // Output the final RGB values
}
