#line 2 //Debugging line

// Saturation Enhancer DCTL - 1.03 //m.c

// Define user interface parameters for DCTL
DEFINE_UI_PARAMS(saturation, Saturation, DCTLUI_SLIDER_FLOAT, 1, 0, 2, 0.01)       // Saturation adjustment control
DEFINE_UI_PARAMS(vibrance, Vibrance, DCTLUI_SLIDER_FLOAT, 1, 0, 2, 0.01)      // Vibrance adjustment control
DEFINE_UI_PARAMS(highlightMask, Highlight Recovery, DCTLUI_SLIDER_FLOAT, 0, 0.0, 1, 0.01) // Highlight recovery strength control
DEFINE_UI_PARAMS(shadowMask, Shadow Recovery, DCTLUI_SLIDER_FLOAT, 0, 0.0, 1, 0.01)  // Shadow recovery strength control
DEFINE_UI_PARAMS(Mix, Mix, DCTLUI_SLIDER_FLOAT, 1.0, 0.0, 1.0, 0.01)                 // Control for mixing processed and original image
DEFINE_UI_PARAMS(showMask, View Mask, DCTLUI_CHECK_BOX, 0)                           // Checkbox to toggle viewing of the mask

// Function to calculate highlight mask based on input RGB and slider value
__DEVICE__ float hMask(float R, float G, float B, float sliderValue) {
    float luminance = 0.299f * R + 0.587f * G + 0.114f * B;        // Calculate luminance
    float multiplier = sliderValue * _powf(luminance, 1.0f);       // Compute multiplier based on luminance
    return _saturatef(_powf(_fmaxf(1.0f - R, 0.0f), multiplier) *  // Calculate highlight mask
                      _powf(_fmaxf(1.0f - G, 0.0f), multiplier) *
                      _powf(_fmaxf(1.0f - B, 0.0f), multiplier));
}

// Function to calculate shadow mask based on input RGB and slider value
__DEVICE__ float sMask(float R, float G, float B, float sliderValue) {
    float luminance = 0.299f * R + 0.587f * G + 0.114f * B;        // Calculate luminance
    float multiplier = sliderValue * (1.0f - _powf(luminance, 1.0f)); // Compute multiplier based on luminance
    return _saturatef(_powf(_fmaxf(R, 0.0f), multiplier / 3.0f) *  // Calculate shadow mask
                      _powf(_fmaxf(G, 0.0f), multiplier / 3.0f) *
                      _powf(_fmaxf(B, 0.0f), multiplier / 3.0f));
}


__DEVICE__ float3 adjustSaturation(float3 rgb, float sat, float vibrance) {
    // Subtract 1 from both Saturation and Vibrance inputs
    sat -= 1.0f;
    vibrance -= 1.0f;

    float ach = _fmaxf(rgb.x, _fmaxf(rgb.y, rgb.z));                                  // Calculate the achromatic axis (brightness level)
    float minColor = _fminf(rgb.x, _fminf(rgb.y, rgb.z));                             // Minimum value among RGB components
    float currentSaturation = ach == 0.0f ? 0.0f : (ach - minColor) / ach;            // Compute current saturation

    // Adjust the application of Vibrance
    float adjustedSaturationEffect = vibrance > 0 ? 
        1.0f + (1.0f - currentSaturation) * vibrance : 
        1.0f + currentSaturation * vibrance;

    // Compute distance from the achromatic axis for saturation adjustment
    float3 distance = ach == 0.0f ? make_float3(0.0f, 0.0f, 0.0f) : (ach - rgb) / _fabs(ach);
    distance *= (1.0f + sat) * adjustedSaturationEffect;

    // Calculate new RGB values with adjusted saturation
    float3 newRGB = ach - distance * _fabs(ach);

    // Clamp the new RGB values to ensure no negative values
    newRGB.x = _fmaxf(newRGB.x, 0.0f);
    newRGB.y = _fmaxf(newRGB.y, 0.0f);
    newRGB.z = _fmaxf(newRGB.z, 0.0f);

    return newRGB;
}


// Main transformation function
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {

    float3 rgb = make_float3(p_R, p_G,p_B);

    // Call adjustSaturation to adjust the saturation and vibrance
    float3 newRGB = adjustSaturation(rgb, saturation, vibrance);

    // Mix the new and original RGB values
    newRGB = rgb * (1.0f - Mix) + newRGB * Mix;

    // Calculate high and low masks for highlight and shadow recovery
    float highMask = 1.0f - hMask(rgb.x, rgb.y, rgb.z, highlightMask);
    float lowMask = 1.0f - sMask(rgb.x, rgb.y, rgb.z, shadowMask);
    float combinedMask = _fminf(highMask + lowMask, 1.0f); // Combine the masks and normalize if needed

    // Combine high and low masks, ensuring the result is non-negative
    float3 outputRGB = rgb * combinedMask + (1.0f - combinedMask) * newRGB;
    outputRGB = make_float3(outputRGB.x, outputRGB.y,outputRGB.z);

    // Check if Show mask box is ticked
    if (showMask) {
        return make_float3(combinedMask, combinedMask, combinedMask); // Output the mask if enabled
    }

    return outputRGB; // Output the final RGB values
}

