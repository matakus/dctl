#line 2

// Temp DCTL // // 1.04 // Matt.C
// Adjsuts the colour temperature based on Black body Radiatior.

#include "zCCTF.dctl"



// UI parameter definitions
DEFINE_UI_PARAMS(p_InputTemperature, Source Kelvin, DCTLUI_SLIDER_FLOAT, 6500.0, 2000.0, 11000.0, 10.0)  // Temperature slider from 2000K to 20000K
DEFINE_UI_PARAMS(p_Temperature, Target Kelvin, DCTLUI_SLIDER_FLOAT, 6500.0, 2000.0, 11000.0, 10.0)            // Temperature slider from 2000K to 20000K
DEFINE_UI_PARAMS(p_Tint, Tint - Green / Magenta, DCTLUI_SLIDER_FLOAT, 0.0, -100.0, 100.0, 1.0)                                // Tint slider from -100 to +100

// Define "Source Input" combo box that pairs colorspace with the transfer function
DEFINE_UI_PARAMS(p_SourceInput, Source Input, DCTLUI_COMBO_BOX, 8, {AcesCCT_AP1, AcesCG_AP1, AppleLog_Rec2020, ArriLogC3_AWG3, ArriLogC4_AWG4, BlackmagicFilmGen5_BMWideGamut, CanonLog2_CanonCinemaGamut, CanonLog3_CanonCinemaGamut, DaVinciIntermediate_DWG, DJI_DLog_DGamut, FilmlightTLog_EGamut, FujiFLog_FGamut, FujiFLog2_FGamut, GoProProtune_GoProGamut, LeicaLLog_Rec2020, PanasonicVLog_VGamut, RedLog3G10_RWG, SonySLog2_SGamut, SonySLog3_SGamut, SonySLog3_SGamutCine, SonySLog3_SGamutVenice, SonySLog3_SGamutVeniceCine}, {Aces CCT / AP1, Aces CG / AP1, Apple Log / Rec2020, Arri LogC3 / AWG3, Arri LogC4 / AWG4, Blackmagic Film Gen5 / BM Wide Gamut, Canon Log 2 / Canon Cinema Gamut, Canon Log 3 / Canon Cinema Gamut, DaVinci Intermediate / DWG, DJI D-Log / D-Gamut, Filmlight T-Log / E-Gamut, Fuji F-Log / F-Gamut, Fuji F-Log2 / F-Gamut, GoPro Protune / GoPro Gamut, Leica L-Log / Rec2020, Panasonic V-Log / V-Gamut, Red Log3G10 / RWG, Sony S-Log2 / S-Gamut 3, Sony S-Log3 / S-Gamut 3, Sony S-Log3 / S-Gamut 3.Cine, Sony S-Log3 / S-Gamut 3 Venice, Sony S-Log3 / S-Gamut 3.Cine Venice})


// Matrix multiplication for 3x3 matrix and vector
__DEVICE__ float3 multiplyMatrix(float3 in, const float mat[9]) {
    float3 out;
    // Perform matrix multiplication for transforming color spaces
    out.x = in.x * mat[0] + in.y * mat[1] + in.z * mat[2];
    out.y = in.x * mat[3] + in.y * mat[4] + in.z * mat[5];
    out.z = in.x * mat[6] + in.y * mat[7] + in.z * mat[8];
    return out;
}

// Convert temperature (Kelvin) to (x, y) chromaticity coordinates and calculate derivatives
__DEVICE__ void temperatureToXYandDerivatives(float temperature, thread float* x_out, thread float* y_out, thread float* dx_dT_out, thread float* dy_dT_out) {
    float x, y;
    float dx_dT, dy_dT;
    float T = temperature;

    // Approximate x based on the input temperature (low vs high)
    if (T <= 4000.0f) {
        x = (-0.2661239e9f / (T * T * T)) - (0.2343580e6f / (T * T)) + (0.8776956e3f / T) + 0.179910f;
        dx_dT = (0.7983717e9f / (T * T * T * T)) + (0.4687160e6f / (T * T * T)) - (0.8776956e3f / (T * T));
    } else {
        x = (-3.0258469e9f / (T * T * T)) + (2.1070379e6f / (T * T)) + (0.2226347e3f / T) + 0.240390f;
        dx_dT = (9.0775407e9f / (T * T * T * T)) - (4.2140758e6f / (T * T * T)) - (0.2226347e3f / (T * T));
    }

    // Compute y and its derivative based on x
    if (T <= 2222.0f) {
        y = -1.1063814f * (x * x * x) - 1.34811020f * (x * x) + 2.18555832f * x - 0.20219683f;
        float dy_dx = -3.3191442f * (x * x) - 2.69622040f * x + 2.18555832f;
        dy_dT = dy_dx * dx_dT;
    } else {
        y = -0.9549476f * (x * x * x) - 1.37418593f * (x * x) + 2.09137015f * x - 0.16748867f;
        float dy_dx = -2.8648428f * (x * x) - 2.74837186f * x + 2.09137015f;
        dy_dT = dy_dx * dx_dT;
    }

    // Output chromaticity coordinates and their derivatives
    *x_out = x;
    *y_out = y;
    *dx_dT_out = dx_dT;
    *dy_dT_out = dy_dT;
}

// Apply tint adjustment to chromaticity coordinates based on tint slider value
__DEVICE__ void applyTintAdjustment(thread float* x_in_out, thread float* y_in_out, float dx_dT, float dy_dT, float tint) {
    // Compute the normal vector to the blackbody locus
    float nx = -dy_dT;
    float ny = dx_dT;

    // Normalize the normal vector
    float length = sqrt(nx * nx + ny * ny);
    if (length > 0.0f) {
        nx /= length;
        ny /= length;

        // Apply tint adjustment along the normal direction
        float tintAdjustment = tint * 0.0005f;  // Tint scaling factor
        *x_in_out += nx * tintAdjustment;
        *y_in_out += ny * tintAdjustment;
    }
}

// CAT02 chromatic adaptation to adjust for different white points
__DEVICE__ float3 applyCAT02Adaptation(float3 XYZ, float3 sourceWhiteXYZ, float3 targetWhiteXYZ) {
    // CAT02 chromatic adaptation matrix
    const float CAT02[9] = {
        0.7328f, 0.4296f, -0.1624f,
        -0.7036f, 1.6975f, 0.0061f,
        0.0030f, 0.0136f, 0.9834f
    };

    // Inverse CAT02 matrix
    const float invCAT02[9] = {
        1.0961238f, -0.278869f, 0.182745f,
        0.454369f, 0.473533f, 0.072098f,
        -0.0096276f, -0.005698f, 1.015326f
    };

    // Convert source and target white points to LMS color space
    float3 LMS = multiplyMatrix(XYZ, CAT02);
    float3 LMS_sourceWhite = multiplyMatrix(sourceWhiteXYZ, CAT02);
    float3 LMS_targetWhite = multiplyMatrix(targetWhiteXYZ, CAT02);

    // Scale LMS values by the ratio of the source and target white points in LMS space
    float3 LMS_adapted;
    LMS_adapted.x = LMS.x * (LMS_targetWhite.x / LMS_sourceWhite.x);
    LMS_adapted.y = LMS.y * (LMS_targetWhite.y / LMS_sourceWhite.y);
    LMS_adapted.z = LMS.z * (LMS_targetWhite.z / LMS_sourceWhite.z);

    // Convert back to XYZ space
    float3 adaptedXYZ = multiplyMatrix(LMS_adapted, invCAT02);
    return adaptedXYZ;
}

// Conversion functions to be selected based on user input for log-to-linear and colorspace transformations
struct ConversionFunctions {
    float3 (*logToLinFunc)(float3 in);
    float3 (*colorspaceToXYZFunc)(float3 in);
};

// Function to select the appropriate conversion functions based on the dropdown
__DEVICE__ ConversionFunctions selectConversionFunctions(int sourceInput) {
    ConversionFunctions funcs;
    // Set log-to-linear and colorspace-to-XYZ functions    
    switch (sourceInput) {
        case 0: // ACES CCT / AP1
            funcs.logToLinFunc = logToLinACEScct;
            funcs.colorspaceToXYZFunc = ACES_CCTtoXYZ;
            break;
        case 1: // ACES CG / AP1
            funcs.logToLinFunc = logToLinACEScc;
            funcs.colorspaceToXYZFunc = ACES_CGtoXYZ;
            break;
        case 2: // Apple Log / Rec2020
            funcs.logToLinFunc = logToLinAppleLogProfile;
            funcs.colorspaceToXYZFunc = AppleLogtoXYZ;
            break;
        case 3: // Arri LogC3 / Arri Wide Gamut 3
            funcs.logToLinFunc = logToLinArriLogC3;
            funcs.colorspaceToXYZFunc = ArriWideGamut3toXYZ;
            break;
        case 4: // Arri LogC4 / Arri Wide Gamut 4
            funcs.logToLinFunc = logToLinArriLogC4;
            funcs.colorspaceToXYZFunc = ArriWideGamut4toXYZ;
            break;
        case 5: // Blackmagic Film Gen5 / BM Wide Gamut
            funcs.logToLinFunc = logToLinBlackmagicFilmGen5;
            funcs.colorspaceToXYZFunc = BlackMagicWideGamutGen5toXYZ;
            break;
        case 6: // Canon Log 2 / Canon Cinema Gamut
            funcs.logToLinFunc = logToLinCanonLog2;
            funcs.colorspaceToXYZFunc = CanonCinemaGamuttoXYZ;
            break;
        case 7: // Canon Log 3 / Canon Cinema Gamut
            funcs.logToLinFunc = logToLinCanonLog3;
            funcs.colorspaceToXYZFunc = CanonCinemaGamuttoXYZ;
            break;
        case 8: // DaVinci Intermediate / DWG
            funcs.logToLinFunc = logToLinDavinciIntermediate;
            funcs.colorspaceToXYZFunc = DaVinciWideGamuttoXYZ;
            break;
        case 9: // DJI D-Log / D-Gamut
            funcs.logToLinFunc = logToLinDJIDLog;
            funcs.colorspaceToXYZFunc = DJIDGamuttoXYZ;
            break;
        case 10: // Filmlight T-Log / E-Gamut
            funcs.logToLinFunc = logToLinFilmLightTLog;
            funcs.colorspaceToXYZFunc = FilmLightEGamuttoXYZ;
            break;
        case 11: // Fuji F-Log / F-Gamut
            funcs.logToLinFunc = logToLinFLog;
            funcs.colorspaceToXYZFunc = FujiFGamuttoXYZ;
            break;
        case 12: // Fuji F-Log2 / F-Gamut
            funcs.logToLinFunc = logToLinFLog2;
            funcs.colorspaceToXYZFunc = FujiFGamuttoXYZ;
            break;
        case 13: // GoPro Protune / GoPro Gamut
            funcs.logToLinFunc = logToLinProtune;
            funcs.colorspaceToXYZFunc = GoProProtuneToXYZ;
            break;
        case 14: // Leica L-Log / Rec2020
            funcs.logToLinFunc = logToLinLeicaLog;
            funcs.colorspaceToXYZFunc = Rec2020toXYZ;
            break;
        case 15: // Panasonic V-Log / V-Gamut
            funcs.logToLinFunc = logToLinVLog;
            funcs.colorspaceToXYZFunc = PanasonicVGamuttoXYZ;
            break;
        case 16: // Red Log3G10 / RWG
            funcs.logToLinFunc = logToLinRedLog3g10;
            funcs.colorspaceToXYZFunc = RedWideGamuttoXYZ;
            break;
        case 17: // Sony S-Log2 / S-Gamut
            funcs.logToLinFunc = logToLinSonySLog2;
            funcs.colorspaceToXYZFunc = SGamut3toXYZ;
            break;
        case 18: // Sony S-Log3 / S-Gamut
            funcs.logToLinFunc = logToLinSonySLog3;
            funcs.colorspaceToXYZFunc = SGamut3toXYZ;
            break;
        case 19: // Sony S-Log3 / S-Gamut.Cine
            funcs.logToLinFunc = logToLinSonySLog3;
            funcs.colorspaceToXYZFunc = SGamut3CinetoXYZ;
            break;
        case 20: // Sony S-Log3 / S-Gamut.Venice
            funcs.logToLinFunc = logToLinSonySLog3;
            funcs.colorspaceToXYZFunc = SGamut3VenicetoXYZ;
            break;
        case 21: // Sony S-Log3 / S-Gamut.VeniceCine
            funcs.logToLinFunc = logToLinSonySLog3;
            funcs.colorspaceToXYZFunc = SGamut3VeniceCinetoXYZ;
            break;
    }

    return funcs;
}


// Struct for conversion functions used for transforming from XYZ back to RGB
struct OutputConversionFunctions {
    float3 (*XYZtoColorspaceFunc)(float3 in);
    float3 (*linToLogFunc)(float3 in);
};

// Select output conversion functions based on the user-selected color space
__DEVICE__ OutputConversionFunctions selectOutputConversionFunctions(int sourceInput) {
    OutputConversionFunctions funcs;
    // Select appropriate XYZ-to-RGB and linear-to-log functions
    switch (sourceInput) {
        case 0: // ACES CCT / AP1
            funcs.XYZtoColorspaceFunc = XYZtoACES_CCT;
            funcs.linToLogFunc = linToLogACEScct;
            break;
        case 1: // ACES CG / AP1
            funcs.XYZtoColorspaceFunc = XYZtoACES_CG;
            funcs.linToLogFunc = linToLogACEScc;
            break;
        case 2: // Apple Log / Rec2020
            funcs.XYZtoColorspaceFunc = XYZtoAppleLog;
            funcs.linToLogFunc = linToLogAppleLogProfile;
            break;
        case 3: // Arri LogC3 / Arri Wide Gamut 3
            funcs.XYZtoColorspaceFunc = XYZtoArriWideGamut3;
            funcs.linToLogFunc = linToLogArriLogC3;
            break;
        case 4: // Arri LogC4 / Arri Wide Gamut 4
            funcs.XYZtoColorspaceFunc = XYZtoArriWideGamut4;
            funcs.linToLogFunc = linToLogArriLogC4;
            break;
        case 5: // Blackmagic Film Gen5 / BM Wide Gamut
            funcs.XYZtoColorspaceFunc = XYZtoBlackMagicWideGamutGen5;
            funcs.linToLogFunc = linToLogBlackmagicFilmGen5;
            break;
        case 6: // Canon Log 2 / Canon Cinema Gamut
            funcs.XYZtoColorspaceFunc = XYZtoCanonCinemaGamut;
            funcs.linToLogFunc = linToLogCanonLog2;
            break;
        case 7: // Canon Log 3 / Canon Cinema Gamut
            funcs.XYZtoColorspaceFunc = XYZtoCanonCinemaGamut;
            funcs.linToLogFunc = linToLogCanonLog3;
            break;
        case 8: // DaVinci Intermediate / DWG
            funcs.XYZtoColorspaceFunc = XYZtoDaVinciWideGamut;
            funcs.linToLogFunc = linToLogDavinciIntermediate;
            break;
        case 9: // DJI D-Log / D-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoDJIDGamut;
            funcs.linToLogFunc = linToLogDJIDLog;
            break;
        case 10: // Filmlight T-Log / E-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoFilmLightEGamut;
            funcs.linToLogFunc = linToLogFilmLightTLog;
            break;
        case 11: // Fuji F-Log / F-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoFujiFGamut;
            funcs.linToLogFunc = linToLogFLog;
            break;
        case 12: // Fuji F-Log2 / F-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoFujiFGamut;
            funcs.linToLogFunc = linToLogFLog2;
            break;
        case 13: // GoPro Protune / GoPro Gamut
            funcs.XYZtoColorspaceFunc = XYZtoGoProProtune;
            funcs.linToLogFunc = linToLogProtune;
            break;
        case 14: // Leica L-Log / Rec2020
            funcs.XYZtoColorspaceFunc = XYZtoRec2020;
            funcs.linToLogFunc = linToLogLeicaLog;
            break;
        case 15: // Panasonic V-Log / V-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoPanasonicVGamut;
            funcs.linToLogFunc = linToLogVLog;
            break;
        case 16: // Red Log3G10 / RWG
            funcs.XYZtoColorspaceFunc = XYZtoRedWideGamut;
            funcs.linToLogFunc = linToLogRedLog3g10;
            break;
        case 17: // Sony S-Log2 / S-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoSGamut3;
            funcs.linToLogFunc = linToLogSonySLog2;
            break;
        case 18: // Sony S-Log3 / S-Gamut
            funcs.XYZtoColorspaceFunc = XYZtoSGamut3;
            funcs.linToLogFunc = linToLogSonySLog3;
            break;
        case 19: // Sony S-Log3 / S-Gamut.Cine
            funcs.XYZtoColorspaceFunc = XYZtoSGamut3Cine;
            funcs.linToLogFunc = linToLogSonySLog3;
            break;
        case 20: // Sony S-Log3 / S-Gamut.Venice
            funcs.XYZtoColorspaceFunc = XYZtoSGamut3Venice;
            funcs.linToLogFunc = linToLogSonySLog3;
            break;
        case 21: // Sony S-Log3 / S-Gamut.VeniceCine
            funcs.XYZtoColorspaceFunc = XYZtoSGamut3VeniceCine;
            funcs.linToLogFunc = linToLogSonySLog3;
            break;
    }
    return funcs;
}


// Main transformation function that applies the temperature and tint adjustments
__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    // Retrieve UI parameters
    float inputTemperature = p_InputTemperature;
    float temperature = p_Temperature;
    float tint = p_Tint;
    int sourceInput = p_SourceInput;

    // Create input RGB
    float3 inputRGB = make_float3(p_R, p_G, p_B);

    // Select conversion functions for the source input
    ConversionFunctions funcs = selectConversionFunctions(sourceInput);

    // Convert from log to linear RGB
    float3 linearRGB = funcs.logToLinFunc(inputRGB);

    // Convert from linear RGB to XYZ
    float3 XYZ = funcs.colorspaceToXYZFunc(linearRGB);

    // Compute source white point in XYZ space
    float x_source, y_source, dx_dT_source, dy_dT_source;
    temperatureToXYandDerivatives(inputTemperature, &x_source, &y_source, &dx_dT_source, &dy_dT_source);
    float Y_source = 1.0f;
    float X_source = (Y_source / y_source) * x_source;
    float Z_source = (Y_source / y_source) * (1.0f - x_source - y_source);
    float3 sourceWhiteXYZ = make_float3(X_source, Y_source, Z_source);

    // Compute target white point and apply tint adjustment
    float x_target, y_target, dx_dT_target, dy_dT_target;
    temperatureToXYandDerivatives(temperature, &x_target, &y_target, &dx_dT_target, &dy_dT_target);
    applyTintAdjustment(&x_target, &y_target, dx_dT_target, dy_dT_target, tint);

    // Convert target chromaticity to XYZ
    float Y_target = 1.0f;
    float X_target = (Y_target / y_target) * x_target;
    float Z_target = (Y_target / y_target) * (1.0f - x_target - y_target);
    float3 targetWhiteXYZ = make_float3(X_target, Y_target, Z_target);

    // Apply chromatic adaptation
    float3 adaptedXYZ = applyCAT02Adaptation(XYZ, sourceWhiteXYZ, targetWhiteXYZ);

    // Select output conversion functions
    OutputConversionFunctions outputFuncs = selectOutputConversionFunctions(sourceInput);

    // Convert from adapted XYZ to RGB and then to log
    float3 linearRGBOut = outputFuncs.XYZtoColorspaceFunc(adaptedXYZ);
    float3 finalRGB = outputFuncs.linToLogFunc(linearRGBOut);

    return finalRGB;
}


